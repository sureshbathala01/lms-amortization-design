# S1.1 v2: New Loan Creation with Python Hooks

**Version**: 2.0 (Python Hybrid Architecture)  
**Date**: November 4, 2025  
**Status**: Implementation Ready  
**Supersedes**: S1.1 v1.0 (Java-only)

---

## Changes from v1.0

**Architecture**: Java-only → Java+Python Hybrid

**Key Changes**:
1. ✅ Pre/post hooks replace inline Java calculation
2. ✅ Python module handles business logic
3. ✅ Schedule generation on-demand (not stored)
4. ✅ Retry mechanism for technical failures
5. ✅ Idempotency support

---

## Complete Flow with Python Hooks

### Phase 1: API Request Reception

```
LOS → POST /api/loans/create
    ↓
Java API Controller receives request
    ↓
Generate correlation_id
    ↓
Load loan data from request
```

**Same as v1.0** - No changes

---

### Phase 2: Basic Validation (Java)

```java
// Java performs basic validations
1. Customer exists? (database lookup)
2. Product version exists and active? (database lookup)
3. Request format valid?

If any fail → Return error immediately
```

**Same as v1.0** - Java handles database validations

---

### Phase 3: PRE-HOOK - Python Business Logic

**NEW IN V2**: Call Python for business validation and calculations

```java
// Java code
public CreateLoanResponse createLoan(LoanRequest request) {
    // Basic validations (Phase 2)
    validateBasic(request);
    
    // PRE-HOOK: Call Python
    String pythonUrl = getPythonContainerUrl(
        request.getProductCode(),
        request.getProductVersion()
    );
    // URL: http://home-loan-v1-2:8001/loan_creation/pre
    
    PythonRequest pythonReq = new PythonRequest();
    pythonReq.setRequestId(UUID.randomUUID().toString());
    pythonReq.setLoanData(request);
    
    PythonResponse pythonResp = pythonClient.callWithRetry(
        pythonUrl + "/loan_creation/pre",
        pythonReq
    );
    
    // Check response
    if (!pythonResp.isValid()) {
        if (pythonResp.isBusinessError()) {
            // Business error - don't retry, fail immediately
            return CreateLoanResponse.error(pythonResp.getErrors());
        } else {
            // Technical error - already retried, still failed
            throw new PythonEngineException("Pre-hook failed after retries");
        }
    }
    
    // Extract calculated values
    Map<String, Object> calculatedValues = pythonResp.getCalculatedValues();
    Map<String, Object> parameters = pythonResp.getParameters();
    
    // Continue to Phase 4...
}
```

**Python Processing**:
```python
# home_loan_v1_2.py
def pre_loan_creation(self, request_data):
    # 1. Business rule validation
    if request_data['principal_amount'] > MAX_AMOUNT:
        return {
            'valid': False,
            'errors': ['Amount exceeds maximum']
        }
    
    # 2. Calculate EMI, totals
    emi = self._calculate_emi(...)
    total_interest = self._calculate_total_interest(...)
    
    # 3. Return results
    return {
        'valid': True,
        'calculated_values': {
            'emi': emi,
            'total_interest': total_interest
        },
        'parameters': {
            'effective_rate': 8.5
        }
    }
```

**Retry Logic** (if technical error):
```
Attempt 1: Network error → Wait 100ms → Retry
Attempt 2: Timeout → Wait 200ms → Retry
Attempt 3: Still failing → Give up, throw exception
```

---

### Phase 4: Database Transaction (Java)

**Same as v1.0** - Java handles all database operations

```java
BEGIN TRANSACTION

1. Create loan record
   - Include python_version column
   - Store calculated values from Python

2. Store parameter overrides
   - From API request
   - Validated by Python pre-hook

COMMIT TRANSACTION
```

**SQL**:
```sql
INSERT INTO loans (
    loan_id,
    customer_id,
    product_code,
    product_version,
    python_version,              -- NEW: Same as product_version
    principal_amount,
    ...
) VALUES (...);

-- NO amortization_schedule table insert
-- Schedule generated on-demand, not stored
```

---

### Phase 5: POST-HOOK - Python Post-Processing

**NEW IN V2**: Call Python after database commit

```java
// Java code (continued)
// Transaction committed successfully

// POST-HOOK: Call Python
PythonRequest postReq = new PythonRequest();
postReq.setRequestId(UUID.randomUUID().toString());
postReq.setLoanData(createdLoan);

PythonResponse postResp = pythonClient.callWithRetry(
    pythonUrl + "/loan_creation/post",
    postReq
);

// Post-hook failures are logged but don't fail the transaction
if (!postResp.isSuccess()) {
    logger.warn("Post-hook failed for loan: {}", loan.getId());
    // Optionally queue for async retry
}

// Process any actions returned by Python
for (Action action : postResp.getActions()) {
    handleAction(action);
}
```

**Python Processing**:
```python
def post_loan_creation(self, loan_data):
    # Post-creation logic (if any)
    # For loan creation, typically minimal
    
    return {
        'status': 'success',
        'actions': [
            {'type': 'LOG', 'message': 'Loan created successfully'}
        ]
    }
```

---

### Phase 6: API Response (Java)

**Same as v1.0** - Return loan ID to LOS

```json
{
  "status": "SUCCESS",
  "packetId": "LN2025110400001",
  "loanStatus": "CREATED",
  "creationDate": "2025-11-04T10:30:45Z"
}
```

---

## Complete Sequence Diagram

```
LOS          Java API          Java DB          Python Container
 |              |                 |                    |
 |--Request---->|                 |                    |
 |              |                 |                    |
 |              |--Validate------>|                    |
 |              |<--Result--------|                    |
 |              |                 |                    |
 |              |--------PRE-HOOK: Business Logic---->|
 |              |                 |                    |
 |              |                 |      [Calculate]   |
 |              |                 |      [Validate]    |
 |              |                 |                    |
 |              |<--Calculated Values & Parameters-----|
 |              |                 |                    |
 |              |--BEGIN TX------>|                    |
 |              |--INSERT LOAN--->|                    |
 |              |--INSERT PARAMS->|                    |
 |              |--COMMIT-------->|                    |
 |              |<--Success-------|                    |
 |              |                 |                    |
 |              |--------POST-HOOK: Post-Processing-->|
 |              |                 |                    |
 |              |                 |      [Minimal]     |
 |              |                 |                    |
 |              |<--Actions---------------------------|
 |              |                 |                    |
 |<--Response---|                 |                    |
```

---

## Error Handling Flows

### Business Error in Pre-Hook

```
Java calls Python pre-hook
    ↓
Python returns: valid=false, errors=[...]
    ↓
Java checks: isBusinessError() = true
    ↓
Java aborts (no retry)
    ↓
Java returns error to LOS
    ↓
No database transaction executed
```

### Technical Error in Pre-Hook with Retry

```
Java calls Python pre-hook (Attempt 1)
    ↓
Network timeout
    ↓
Retry logic: Wait 100ms
    ↓
Java calls Python pre-hook (Attempt 2)
    ↓
Connection refused
    ↓
Retry logic: Wait 200ms
    ↓
Java calls Python pre-hook (Attempt 3)
    ↓
Success!
    ↓
Continue to database transaction
```

### Technical Error - Max Retries Exceeded

```
Java calls Python pre-hook (Attempt 1)
    ↓
Timeout
    ↓
Retry (Attempt 2)
    ↓
Timeout
    ↓
Retry (Attempt 3)
    ↓
Timeout
    ↓
Max retries exceeded
    ↓
Throw PythonEngineException
    ↓
Java returns error to LOS
```

### Post-Hook Failure (Non-Critical)

```
Database transaction COMMITTED
    ↓
Java calls Python post-hook
    ↓
Post-hook fails
    ↓
Java logs error/warning
    ↓
Optionally queue for async retry
    ↓
Return SUCCESS to LOS (loan already created)
```

---

## Data Model Changes

### loans Table (Modified)

```sql
ALTER TABLE loans ADD COLUMN python_version VARCHAR(20);

-- python_version stores the Python module version
-- Same as product_version for consistency
```

### amortization_schedule Table (REMOVED)

```sql
-- This table is NO LONGER USED
-- Schedule generated on-demand, not stored
DROP TABLE IF EXISTS amortization_schedule;
```

### Why Remove Schedule Storage?

1. ✅ Always uses correct Python version logic
2. ✅ No stale data
3. ✅ Simplifies data model
4. ✅ Schedule can be regenerated anytime
5. ✅ Performance acceptable (calculation is fast)

---

## Schedule Generation (On-Demand)

### When to Generate Schedule?

**Simulation** (before disbursement):
```java
// Anytime via separate API
GET /api/loans/{loanId}/simulate-schedule

// Calls Python: generate_schedule()
// Returns schedule JSON (not stored)
```

**Actual** (after disbursement):
```java
// During post_payment_posting hook
// When disbursement posted

Python post_payment_posting():
    schedule = self.generate_schedule(loan)
    return {'schedule': schedule}

// Java receives schedule in response
// Can display or return to caller
// But NOT stored in database
```

### Schedule Generation API

```python
def generate_schedule(self, loan_data):
    # Calculate complete amortization schedule
    # Based on current loan state
    # Uses Python version logic
    
    installments = []
    for i in range(1, tenure + 1):
        # Calculate each installment
        installments.append({...})
    
    return {
        'loan_id': loan_data['loan_id'],
        'generated_date': today,
        'installments': installments,
        'summary': {...}
    }
```

---

## Performance Considerations

### Latency Added by Python Calls

**Pre-Hook**: ~20-50ms  
**Post-Hook**: ~50-100ms (includes schedule generation)  
**Total Added**: ~70-150ms

**Acceptable because**:
- Loan creation is not high-frequency operation
- Business value (flexibility) outweighs latency
- Can optimize with gRPC in Phase 2

### Retry Impact

**With Retries**: Can add up to 500ms in worst case
- Attempt 1: 100ms timeout
- Wait: 100ms
- Attempt 2: 100ms timeout
- Wait: 200ms
- Total: ~500ms

**Mitigation**:
- Set appropriate timeouts
- Circuit breaker prevents cascade
- Monitoring alerts on high retry rates

---

## Monitoring & Observability

### Metrics to Track

**Java Side**:
```
lms.python.calls.total
lms.python.calls.success
lms.python.calls.errors.business
lms.python.calls.errors.technical
lms.python.calls.retries
lms.python.calls.latency.p50
lms.python.calls.latency.p95
lms.python.calls.latency.p99
```

**Python Side**:
```
python.hook.execution.time
python.hook.errors
python.calculation.time
```

### Logging

**Java**:
```java
logger.info("Calling Python pre-hook", 
    "correlation_id", correlationId,
    "product", productCode,
    "version", productVersion);

logger.info("Python pre-hook completed",
    "correlation_id", correlationId,
    "status", response.getStatus(),
    "duration_ms", duration);
```

**Python**:
```python
logger.info(f"Processing pre_loan_creation",
    extra={
        'correlation_id': correlation_id,
        'request_id': request_id,
        'product': self.product_code,
        'version': self.version
    })
```

---

## Testing Strategy

### Unit Tests

**Java** (Mock Python):
```java
@Test
public void testLoanCreation_pythonSuccess() {
    // Mock Python response
    PythonResponse mockResp = new PythonResponse();
    mockResp.setValid(true);
    mockResp.setCalculatedValues(Map.of("emi", 50000));
    
    when(pythonClient.call(any(), any())).thenReturn(mockResp);
    
    // Test
    CreateLoanResponse response = orchestrator.createLoan(request);
    
    assertThat(response.getStatus()).isEqualTo("SUCCESS");
    verify(loanRepository).save(any());
}
```

**Python** (Isolated):
```python
def test_pre_loan_creation_validation():
    calculator = HomeLoanV1_2()
    
    request = {'principal_amount': 20000000}  # Exceeds max
    result = calculator.pre_loan_creation({'loan_data': request})
    
    assert result['valid'] == False
    assert 'PRINCIPAL_TOO_HIGH' in result['errors'][0]['code']
```

### Integration Tests

**End-to-End with Real Containers**:
```java
@SpringBootTest
@Testcontainers
public class LoanCreationIntegrationTest {
    
    @Container
    private static GenericContainer python = 
        new GenericContainer("home-loan-v1-2:latest")
            .withExposedPorts(8001);
    
    @Test
    public void testCompleteFlow() {
        CreateLoanResponse response = api.createLoan(request);
        
        assertThat(response.getStatus()).isEqualTo("SUCCESS");
        assertThat(response.getPacketId()).isNotEmpty();
        
        // Verify loan in database
        Loan loan = loanRepository.findById(response.getPacketId());
        assertThat(loan.getStatus()).isEqualTo("CREATED");
    }
}
```

---

## Migration from v1.0 to v2.0

### Deployment Strategy

1. **Deploy Python containers** (all product versions)
2. **Update Java application** (with Python client)
3. **Feature flag** to control which products use Python
4. **Gradual rollout** (one product at a time)
5. **Monitor and validate**
6. **Complete migration**

### Backward Compatibility

- Old Java product classes remain available
- Can fallback if Python unavailable
- Reversible migration

---

## Success Criteria

S1.1 v2.0 successful when:

1. ✅ Loan creation works with Python pre/post hooks
2. ✅ Business validations in Python
3. ✅ Calculations in Python
4. ✅ Retry mechanism handles technical failures
5. ✅ Performance acceptable (< 500ms end-to-end)
6. ✅ Schedule generation on-demand works
7. ✅ Complete audit trail maintained

---

## Related Documents

- [S1.1 v1.0 (Java-only)](S1.1-new-loan-creation.md)
- [Architecture Comparison](../../06-technical-design/architecture-comparison-java-python.md)
- [Java-Python Integration](../../06-technical-design/java-python-integration.md)
- [Python Module Specification](../../06-technical-design/python-module-specification.md)

---

## Change Log

| Date | Version | Changes |
|------|---------|---------|
| 2025-11-04 | 2.0 | Updated for Java+Python hybrid architecture |
| 2025-11-04 | 1.0 | Initial Java-only version |
